#!/usr/bin/env ruby

require 'optparse'
require 'benchmark'
require 'game'

rules = []
exclude = []
n = 100

opts = OptionParser.new
opts.on( "-r", "--rules RULES"   ) { |r| rules << Kernel.const_get( r ) }
opts.on( "-e", "--exclude RULES" ) { |r| exclude << Kernel.const_get( r ) }
opts.on( "-n", "--number NUM"    ) { |n| n = Integer( n ) }

opts.parse( ARGV )

rules = Rules.list if rules.empty?
exclude.each { |r| rules.delete( r ) }

Benchmark.bm( 30 ) do |x|
  rules.each do |r|
    pos = r.new
    op = pos.ops.first
    p_a = Array.new( n ) { |i| pos.dup }

    x.report( "#{r} position dup" ) do
      n.times { pos.dup }
    end

    x.report( "#{r} init" ) do
      n.times { r.new }
    end

    x.report( "#{r} op?" ) do
      n.times { pos.op?( op ) }
    end

    x.report( "#{r} ops" ) do
      n.times { pos.ops }
    end

    x.report( "#{r} apply" ) do
      p_a.each { |p| p.apply( op ) }
    end

    x.report( "#{r} final?" ) do
      n.times { pos.final? }
    end

    x.report( "#{r} random play" ) do
      g = Game.new( r )
      n.times do
        g = Game.new( r ) if g.final?
        g << g.ops[rand(g.ops.length)]
      end
    end
  end
end

